---
title: 'OHI 2019 - Fisheries Management Index (Resilience)'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '../../../src/templates/ohi_hdr.html'
  pdf_document:
    toc: true
editor_options: 
  chunk_output_type: console
---


# Summary
This document describes the steps for obtaining and wrangling the data used to calculate the fisheries management index resilience layer for the 2019 global assessment.

# Data Sources

The following data are used:

## Fisheries Management Index Data 
Add some detail about this data.

* [Fisheries Management Index](https://oursharedseas.com/2019-update/fisheries/#highchart-fisheries-fmindex)

**Date retreived:** 12 July 2019

**Method:** Data are not accessible in csv format from website, so points were manually entered into excel and saved as a csv (found in v2019/raw)

## GDP per capita 

Fisheries management index scores are highly correlated with GDP, so GDP per capita per person purchasing power (gdppcpppp) was used to create linear regression models to gapfill FMI data. We used World Bank data (reported at country-scale) and gapfilled any missing GDP values using CIA data. 

[World bank](http://data.worldbank.org/indicator/NY.GDP.PCAP.PP.KD) 
* Downloaded 7/24/19
* Time range: 1990-2018

[CIA World Factbook](https://www.cia.gov/library/publications/the-world-factbook/rankorder/2004rank.html)
* Downloaded 7/24/19
* Time range: 


# Updates from previous assessment
These data have not been updated since 2013, so this is an entirely new method for establishing resilience values. 



# Initial set-up code

```{r setup, message=FALSE, warning=FALSE}

#library(devtools)
#devtools::install_github("ohi-science/ohicore@dev")
library(ohicore)
library(tidyverse)
library(stringr)
library(WDI) # for accessing World Bank data 
library(here) 
library(plotly)
library(psych) # for correlation testing

source('https://raw.githubusercontent.com/OHI-Science/ohiprep_v2019/gh-pages/workflow/R/common.R')



```

# Load and wrangle FMI data 

```{r}
fmi_raw <- read_csv(here("globalprep/res_fmi/v2019/raw/FMI_data_raw.csv")) %>%
  rename("2016" = fmi_2016) %>% 
  rename("2018" = fmi_2018) %>% 
  gather(key = "year", value = "fmi", -country)

# Add region ID
fmi_rgn <- name_2_rgn(df_in = fmi_raw, 
                       fld_name='country', 
                       flds_unique=c('fmi', 'year')) %>% 
  select(rgn_id, rgn_name, year, fmi) %>% 
  filter(year == 2018) # remove 2016 points so that they don't skew the model

fmi_rgn$year <- as.numeric(fmi_rgn$year)

```


## Load data from Social Progress Index (SPI) + UN Georegions, create linear models for gapfilling
```{r}

## Load SPI data

spi <- read_csv(here("globalprep/prs_res_spi/v2018/output/spi_res.csv"))
# can update this for 2019 once we complete this layer 

fmi_spi <- fmi_rgn %>% 
  left_join(spi, by=c("rgn_id","year")) %>% 
  select(-rgn_name)

# Load UN georegion data 
UNgeorgn()

georegions <- UNgeorgn %>%
  select(rgn_id, rgn_name = rgn_label, r0_label, r1_label, r2_label)

fmi_georegions <- fmi_rgn %>% 
  left_join(georegions, by=c("rgn_id","rgn_name"))

all_layers <- fmi_spi %>% 
  rename(spi = resilience_score) %>% 
  left_join(fmi_georegions, by = c("rgn_id", "year", "fmi")) %>% 
  select(rgn_id, rgn_name, fmi, spi, r0_label, r2_label, r1_label)
  
mod6 <- lm(fmi ~ spi + r2_label, data=all_layers)
summary(mod6)  # r^2 = 0.6583

mod6.5 <- lm(fmi ~ spi + r1_label, data=all_layers)
summary(mod6.5)  # r^2 = 0.5776


```


# Gapfilling regions without FMI scores using best fit model
More information about the linear model process development can be found in fmi_model_compare.Rmd and the [Github issue from v2019](https://github.com/OHI-Science/globalfellows-issues/issues/91). 
```{r}

# Create vector to filter out low population regions so that they are NA 
low_pop()
low_pop <- low_pop %>%
  filter(est_population < 3000 | is.na(est_population)) #filter out regions that have populations > 3000 and keep NA values 
low_pop_vector <- c(low_pop$rgn_id) #make a vector of rgn_ids of low population areas 

fmi_gf <- UNgeorgn %>% 
  merge(spi) %>%
  filter(year==2018) %>% 
  left_join(fmi_rgn, by=c("rgn_id", "year")) %>%
  mutate(rgn_label = as.character(rgn_label)) %>% 
  mutate(rgn_label = ifelse(str_detect(rgn_label, "R_union"), "Reunion", rgn_label)) %>% 
  select(-rgn_name, -r0_label, spi=resilience_score)

# Separate out low population/uninhabited regions from the data frame to be gapfilled
low_pop_regions <- fmi_gf %>% 
  filter(rgn_id %in% low_pop_vector)

# Remove low pop regions from data to be gapfilled
fmi_gf <- fmi_gf %>% 
  filter(!rgn_id %in% low_pop_vector)


# Create array of predicted FMI values using fmi ~ spi + r1_label
fmi_gf1 <- fmi_gf %>%
  dplyr::group_by(rgn_id) %>%
  dplyr::do({ 
    fmi_pred_r1 <- predict(mod6.5, newdata =.[c('r1_label', 'spi')]) 
    data.frame(., fmi_pred_r1) # do loop applies the model fitting and prediction to each country group
  }) %>% 
  dplyr::ungroup()


# Create array of predicted FMI values using fmi ~ spi + r2_label
fmi_gf2 <- fmi_gf %>%
  filter(r2_label != "Melanesia") %>% # Melanesia does not have any FMI data points in df used to train mod6
  filter(r2_label != "Polynesia") %>% # same issue ^
  filter(r2_label != "Western Asia") %>% 
  dplyr::group_by(rgn_id) %>%
  dplyr::do({ 
    fmi_pred_r2 <- predict(mod6, newdata =.[c('r2_label', 'spi')]) 
    data.frame(., fmi_pred_r2) # do loop applies the model fitting and prediction to each country group
  }) %>% 
  dplyr::ungroup()


# Rejoin regions gapfilled with r1, assign best predicted FMI scores to populated regions without FMI data
# Check to see if r2 has a value, if so use that to gapfill `score`, otherwise use r1, otherwise use r0

fmi_gf_all <- fmi_gf1 %>%
  left_join(fmi_gf2, by=c("rgn_id", "r1_label", "r2_label", "rgn_label", "year", "spi", "fmi")) %>% 
  mutate(gapfilled = ifelse(is.na(fmi) & !is.na(fmi_pred_r2), "1", 0)) %>%
  mutate(method = ifelse(is.na(fmi) & !is.na(fmi_pred_r2), "SPI + UN_geopolitical region r2", NA)) %>%
  mutate(fmi = ifelse(is.na(fmi), fmi_pred_r2, fmi)) %>% 
  mutate(gapfilled = ifelse(is.na(fmi) & !is.na(fmi_pred_r1), "1", gapfilled)) %>%
  mutate(method = ifelse(is.na(fmi) & !is.na(fmi_pred_r1), "SPI + UN_geopolitical region r1", method)) %>%
  mutate(fmi = ifelse(is.na(fmi), fmi_pred_r1, fmi))

# Rejoin regions with low populations 
final_fmi <- fmi_gf_all %>%
  select("rgn_id", "r1_label", "r2_label", "rgn_label", "year", "spi", "fmi") %>% 
  rbind(low_pop_regions) %>%  # these 20 regions will have NAs
  select(rgn_id, year, value=fmi)

# Save the data 
write_csv(final_fmi, here("globalprep/res_fmi/v2019/output/fmi_res.csv"))

# Add gapfilling info to low pop regions
low_pop_regions_gf <- low_pop_regions %>% 
  mutate(gapfilled = 0) %>% 
  mutate(method = "Not gapfilled due to low pop") %>% 
  select(rgn_id, year, gapfilled, method)

# Save dataframe with gapfilled method and status information
final_fmi_gf <- fmi_gf_all %>%
  select(rgn_id, year, gapfilled, method) %>% 
  rbind(low_pop_regions_gf)

write_csv(final_fmi_gf, here("globalprep/res_fmi/v2019/output/fmi_res_gf.csv"))


```

## Compare to Mora data from 2013

```{r}

# Load old data (not sure which file to use for comparions?)

mora <- read_csv(here("globalprep/res_mora_ao/v2013/data/r_mora_2013a.csv"))

mora_s4 <- read_csv(here("globalprep/res_mora_ao/v2013/data/r_mora_s4_2013a.csv"))

mora_s4_updated <- read_csv(here("globalprep/res_mora_ao/v2013/data/r_mora_s4_2013a_updated.csv"))

mora_v_fmi <- final_fmi %>% 
  rename(fmi_2019=value) %>% 
  left_join(mora, by="rgn_id") %>% 
  rename(mora=value)

# Compare gapfilled FMI scores with Mora data
ggplotly(ggplot(mora_v_fmi, aes(x = mora, y = fmi_2019, labels = rgn_id)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red"))


# No correlation here - compare non-gapfilled data only with Mora data:

mora_v_fmi2 <- fmi_rgn %>% 
  rename(fmi_2019=fmi) %>% 
  left_join(mora, by="rgn_id") %>% 
  rename(mora=value)

ggplotly(ggplot(mora_v_fmi2, aes(x = mora, y = fmi_2019, labels = rgn_id)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red"))

# Also no correlation; lack of relationship can be attributed to source data rather than gapfilling method. 
```

