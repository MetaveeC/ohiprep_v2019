---
title: 'OHI 2019 - Fisheries Management Index (Resilience)'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '../../../src/templates/ohi_hdr.html'
  pdf_document:
    toc: true
editor_options: 
  chunk_output_type: console
---


# Summary
This document describes the steps for obtaining and wrangling the data used to calculate the fisheries management index resilience layer for the 2019 global assessment.

# Data Sources

The following data are used:

## Fisheries Management Index Data 
Add some detail about this data.

* [Fisheries Management Index](https://oursharedseas.com/2019-update/fisheries/#highchart-fisheries-fmindex)

**Date retreived:** 12 July 2019

**Method:** Data are not accessible in csv format from website, so points were manually entered into excel and saved as a csv (found in v2019/raw)

Data was available for only 40 regions.  We used our rescaled and gapfilled version of the Social Progress Index and UN geogregion data to estimate missing regions.

# Updates from previous assessment
These data have not been updated since 2013, so this is an entirely new method for establishing resilience values. 


# Initial set-up code

```{r setup, message=FALSE, warning=FALSE}

#library(devtools)
#devtools::install_github("ohi-science/ohicore@dev")
library(ohicore)
library(tidyverse)
library(stringr)
library(WDI) # for accessing World Bank data 
library(here) 
library(plotly)
library(psych) # for correlation testing

source('https://raw.githubusercontent.com/OHI-Science/ohiprep_v2019/gh-pages/workflow/R/common.R')



```

# Load and wrangle FMI data 

```{r}
fmi_raw <- read_csv(here("globalprep/res_fmi/v2019/raw/FMI_data_raw.csv")) %>%
  rename("2016" = fmi_2016) %>% 
  rename("2018" = fmi_2018) %>% 
  gather(key = "year", value = "fmi", -country)

# Add region ID
fmi_rgn <- name_2_rgn(df_in = fmi_raw, 
                       fld_name='country', 
                       flds_unique=c('fmi', 'year')) %>% 
  select(rgn_id, rgn_name, year, fmi) %>% 
  filter(year == 2018) # remove 2016 points so that they don't skew the model

fmi_rgn$year <- as.numeric(fmi_rgn$year)

```


## Load data from Social Progress Index (SPI) + UN Georegions, create linear models for gapfilling
```{r}

## Load SPI data

spi <- read_csv(here("globalprep/prs_res_spi/v2018/output/spi_res.csv"))
# can update this for 2019 once we complete this layer 

fmi_spi <- fmi_rgn %>% 
  left_join(spi, by=c("rgn_id","year")) %>% 
  select(-rgn_name)

# Load UN georegion data 
UNgeorgn()

georegions <- UNgeorgn %>%
  select(rgn_id, rgn_name = rgn_label, r0_label, r1_label, r2_label)

fmi_georegions <- fmi_rgn %>% 
  left_join(georegions, by=c("rgn_id","rgn_name"))

all_layers <- fmi_spi %>% 
  rename(spi = resilience_score) %>% 
  left_join(fmi_georegions, by = c("rgn_id", "year", "fmi")) %>% 
  select(rgn_id, rgn_name, fmi, spi, r0_label, r2_label, r1_label)
  
mod6 <- lm(fmi ~ spi + r2_label, data=all_layers)
summary(mod6)  # r^2 = 0.6583
plot(predict(mod6), all_layers$fmi)
abline(0,1, col="red")

mod6.5 <- lm(fmi ~ spi + r1_label, data=all_layers)
summary(mod6.5)  # r^2 = 0.5776
plot(predict(mod6.5), all_layers$fmi)
abline(0,1, col="red")


```


# Gapfilling regions without FMI scores using best fit model
More information about the linear model process development can be found in fmi_model_compare.Rmd and the [Github issue from v2019](https://github.com/OHI-Science/globalfellows-issues/issues/91). 
```{r}

fmi_gf <- UNgeorgn %>% 
  merge(spi) %>%
  filter(year==2018) %>% 
  left_join(fmi_rgn, by=c("rgn_id", "year")) %>%
  mutate(rgn_label = as.character(rgn_label)) %>% 
  mutate(rgn_label = ifelse(str_detect(rgn_label, "R_union"), "Reunion", rgn_label)) %>% 
  select(-rgn_name, -r0_label, spi=resilience_score)


# Create array of predicted FMI values using fmi ~ spi + r2_label

mod_r2 <- lm(fmi ~ r2_label + spi, data=fmi_gf)
## have to do the predict in a more complicated fashion because some r2 categories have no data, this returns an NA for these
fmi_gf$fmi_pred_r2 <- 
  sapply(1:nrow(fmi_gf), 
           function(i) 
               tryCatch(predict(mod_r2, fmi_gf[i,]), 
                           error=function(e) NA))

# get predictions for the regions not represented by r2 regions:
mod_r1 <- lm(fmi ~ r1_label + spi, data=fmi_gf)
## have to do the predict in a more complicated fashion because some r2 categories have no data, this returns an NA for these
fmi_gf$fmi_pred_r1 <- 
  sapply(1:nrow(fmi_gf), 
           function(i) 
               tryCatch(predict(mod_r1, fmi_gf[i,]), 
                           error=function(e) NA))

# final data and gapfilling recordkeeping

fmi_gf_all <- fmi_gf %>%
  dplyr::mutate(gapfilled = ifelse(is.na(fmi), "1", 0)) %>%
  dplyr::mutate(method = ifelse(is.na(fmi) & !is.na(fmi_pred_r2), "SPI + UN_geopolitical region r2", NA)) %>%
  dplyr::mutate(method = ifelse(is.na(fmi) & is.na(fmi_pred_r2), "SPI + UN_geopolitical region r1" , method)) %>%
  dplyr::mutate(fmi2 = ifelse(is.na(fmi), fmi_pred_r2, fmi)) %>% 
  dplyr::mutate(fmi2 = ifelse(is.na(fmi2), fmi_pred_r1, fmi2)) %>%
  dplyr::mutate(fmi = fmi2) %>%
  dplyr::select(-fmi2)


# make sure all low/no population regions are NA 
low_pop()
low_pop <- low_pop %>%
  filter(est_population < 3000 | is.na(est_population)) #filter out regions that have populations > 3000 and keep NA values 

fmi_gf_low_pop <- fmi_gf_all %>%
  dplyr::filter(rgn_id %in% low_pop$rgn_id)
summary(fmi_gf_low_pop)
  

## Make sure all other regions have an fmi value
fmi_gf_with_pop <- fmi_gf_all %>%
  dplyr::filter(!(rgn_id %in% low_pop$rgn_id))
summary(fmi_gf_with_pop)


# Correct gapfilling info to low pop regions
fmi_gf_all <- fmi_gf_all %>% 
  mutate(gapfilled = ifelse(rgn_id %in% low_pop$rgn_id, 0, gapfilled)) %>% 
  mutate(method = ifelse(rgn_id %in% low_pop$rgn_id, NA, method))

## format final data
fmi_final <- fmi_gf_all %>%
  select(rgn_id, year, value=fmi)
dim(fmi_final) # all regions represented
summary(fmi_final) # 20 NA values


# Save the data 
write_csv(fmi_final, here("globalprep/res_fmi/v2019/output/fmi_res.csv"))


# Save dataframe with gapfilled method and status information
final_fmi_gf <- fmi_gf_all %>%
  select(rgn_id, year, gapfilled, method)
write_csv(final_fmi_gf, here("globalprep/res_fmi/v2019/output/fmi_res_gf.csv"))


```

## Compare to Mora data from 2013

```{r}

# Load old data (not sure which file to use for comparions?)

mora <- read_csv(here("globalprep/res_mora_ao/v2013/data/r_mora_2013a.csv"))

mora_v_fmi <- fmi_final %>% 
  rename(fmi_2019=value) %>% 
  left_join(mora, by="rgn_id") %>% 
  rename(mora=value)

# Compare gapfilled FMI scores with Mora data
ggplotly(ggplot(mora_v_fmi, aes(x = mora, y = fmi_2019, labels = rgn_id)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red"))


# Not a great correlation here - compare non-gapfilled data only with Mora data:

mora_v_fmi2 <- fmi_rgn %>% 
  rename(fmi_2019=fmi) %>% 
  left_join(mora, by="rgn_id") %>% 
  rename(mora=value)

ggplotly(ggplot(mora_v_fmi2, aes(x = mora, y = fmi_2019, labels = rgn_id)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red"))

# Also not a great correlation; differences can be attributed to source data rather than gapfilling method. 
```

