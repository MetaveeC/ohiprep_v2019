---
title: "Fix Cell Issues"
date: "8/23/2018"
output: html_document
---

# Summary

From Jamie's clean_cells.R script in v2017. This script fixes the issue of some half degree cells that slighlty overlap the OHI regions shapefile, leaving them with a proportional area less than 1. This would cause us to lose catch when assigning catch to cells. To fix this, we define a vector of cellids that have a proportionArea <1 and are NOT duplicated (i.e. the other portion of the area missing is not accounted for) and assign a proportionArea of 1 to these cells.

Also takes code from [saup_rasters_to_ohi_rgns.R](https://github.com/OHI-Science/ohiprep_v2018/blob/9ed3d24d6ef293ef21443fb0957e0aa0d4cb8970/globalprep/fis/v2016/saup_rasters_to_ohi_rgns.R) to re-write fao and ohi regions with cell information.

The output is saved as cells.csv

# Setup 

```{r}
library(reshape2)
library(tidyverse)
library(seaaroundus)
library(rgdal)
library(raster)
library(here)

setwd(here::here("globalprep/fis/v2018"))
source('../../../src/R/common.R')
source('../../../src/R/spatial_common.R')

```

# Methods

## Set up a watson cell ID raster

Metadata for Watson 2017 Cells data [here](https://www.nature.com/articles/sdata201739/tables/2). The column name is **Seq**, but Watson 2018 data calls it **Cells**.
```{r}
watson_rast <- raster(extent(c(-180, 180, -90, 90)), res = 0.5, crs = '+init=epsg:4326')
values(watson_rast) <- 1:ncell(watson_rast) # should have 260 rows and 720 columns
```

## Associate Cell ID with OHI regions

Script taken from [v2016 saup_rasters_to_ohi_rgns.R script](https://github.com/OHI-Science/ohiprep_v2018/blob/9ed3d24d6ef293ef21443fb0957e0aa0d4cb8970/globalprep/fis/v2016/saup_rasters_to_ohi_rgns.R). 

Result of `ohi_to_saup_raster` will be a list of length 526 (the same number of rows in the shapefile **regions**). Each element in the list will be associated with at least one cell number in a range from 1 to `ncell(watson_rast)` or 259,200. 

Note: When using spatial polygons (e.g. **regions**) in `extract`, the extract method returns the values of the cells of a Raster object (e.g. **watson_rast**) that are covered by a polygon. A cell is covered if its center is inside the polygon, but setting `weights = TRUE` and `normalizeWeights = FALSE` accounts from the fraction of each cell that is covered by each polygon.
```{r}

## some overlap between these fao region polygons (check it out):
plot(regions[1][regions$rgn_id %in% c(260,262),])

## associate each cell value with ohi and fao regions
ohi_to_saup_raster <- raster::extract(watson_rast, regions, weights = TRUE, normalizeWeights = FALSE, progress = 'text') 

## assign rgn type and id (e.g. eez_100) to each element in the list
names(ohi_to_saup_raster) <- paste(regions$type_w_ant, regions$rgn_ant_id, sep="_")

## combine all 526 elements into a data frame with col names '.id', 'value', and 'weight'
region_prop_df <- plyr::ldply(ohi_to_saup_raster, rbind)

## splits up rgn type and id, rename col
all_df <- region_prop_df %>%
  separate(.id, c('rgn_typ', 'rgn_id'), sep = '_') %>%
  rename(wat_cell_id = value, 
         proportionArea = weight)

## save all the cell associations
write.csv(all_df, file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_ohi_rgns.csv"), row.names=FALSE)

## save only the ocean cells (this will probably be the file we actually need)
ocean_df <- all_df %>%
  filter(rgn_typ %in% c("eez", 'eez-ccamlr', 'eez-disputed', 'eez-inland', 'fao'))

write.csv(ocean_df, file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_ohi_rgns_noLand.csv"), row.names=FALSE)

```

### Check Cell Proportions

Calculate total proportion of each cell within each eez - should add up to 1.
```{r}
cells_raw <- read.csv(file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_ohi_rgns.csv")) %>%
  rename(CellID = wat_cell_id) %>%
  group_by(CellID) %>%
  mutate(total_area = sum(proportionArea)) 
```

List of cells with areas > 1 (indicates something strange is going on)
```{r}
bad_ones <- cells_raw %>% 
  filter(total_area >1) %>%
  arrange(CellID) 

data.frame(bad_ones)
```

### Compile List of Region Types

For each cell ID, create new column listing all the associated region types. 

Helps to identify cells with EEZ or FAO categories and used later to determine whether cells with OHI regions but no FAO region are an issue:
```{r}

cells_water <- cells_raw %>%
  group_by(CellID) %>%
  mutate(cell_rgns = paste(sort(unique(rgn_typ)), collapse=", ")) %>%
  arrange(CellID)

```

Check this went ok:
```{r}
unique(cells_water$cell_rgns)
list <- table(cells_water$cell_rgns)
list

## Look at cells with both eez and land
filter(cells_water, cell_rgns=="eez, land")
```

Subset region types in the ocean only cells data frame.

```{r}
# List the types of cells we want to keep
eez_fao_cats <- c("eez", "eez-ccamlr", "eez-ccamlr, land-ccamlr", "eez-disputed",
                  "eez-disputed, fao", "eez-disputed, land-disputed", "eez-disputed, land, land-disputed", "eez, eez-ccamlr",
                  "eez, eez-disputed", "eez, eez-disputed, fao", "eez, eez-disputed, land", "eez, eez-disputed, land-disputed",
                  "eez, eez-disputed, land, land-disputed", "eez, fao", "eez, land", "eez, land, land-noeez", "fao")      


cells_water <- cells_water %>%
  filter(CellID, cell_rgns %in% eez_fao_cats)
```

### Adjust for Area Not Equal to 1

Cells should have a total area of <=1. What causes some cells to have more...and is this a large problem? No, most cells are fine. This seems to happen because of polygon overlap.

* scenario 1: FAO region 262 overlaps other FAO region polygons by a small amount. In this case a small proportion of the catch within a cell will be assigned to two regions.  This will be a small error. (No correction)
* scenario 2: In many cases, the total area is very close to 1 which may reflect rounding error and is not significant. (Usually no correction)
* scenario 3: In some cases, the regions are small islands where there doesn't appear to be a hole so both the land and underlying eez are counted. 

This can also occur along any eez/land boundary...but it looks like it mainly happens for islands. If the overlap is for land/eez within the same region, this will be corrected. 

Scenario 3:
```{r}

cells <- read.csv(file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_ohi_rgns.csv")) %>%
  rename(CellID = wat_cell_id) %>%
  group_by(CellID, rgn_id) %>%   # groups land and eez data (that way the cell catch is fully applied to the region...rather than cutting the portion that overlaps land) 
  dplyr::summarise(area = sum(proportionArea)) %>%
  mutate(area = ifelse(area > 1, 1, area))%>%  # this corrects when there is land/eez overlap within the same region resulting in cell area >1 (scenario 3 above)
  ungroup()  
```

Scenario 1 and 2:

Remaining errors from scenario 1 and 2 above. Take a look at the cells that have overlapping area (total area greater than 1). These are very small errors..nothing to be concerned about.
```{r}
bad_ones <- cells %>%
  group_by(CellID) %>%
  mutate(total_cell_area = sum(area)) %>%
  filter(total_cell_area > 1) %>%
  arrange(CellID) 

data.frame(bad_ones)
```

Get the list of cell ids that are duplicated, and use this list of values to adjust the area to equal 1 ONLY for those cells that are not duplicated (wait what is this doing?
```{r}
## Id duplicated cells:
dup <- cells$CellID[duplicated(cells$CellID)]
```

Check cells with area less than 1. These are the cells that were cut off prematurely due to edge effects, etc.
```{r}
tmp <- cells %>% 
  filter(!(CellID %in% dup) & area < 1)
head(tmp)
```

*** 

## Match Cells with FAO Regions

Repeat similar steps for extracting cell values for FAO regions as you did with the OHI shapefile.

Note: Not going to worry about weights in this case, error should be marginal due to large size of FAO regions. In other words, for each cell, will assign it the fao region that overlaps the most with that cell. This will also make combining with the ohi-region data far less confusing. (confused about this comment as we do set weights=TRUE in `extract`. Iwen 8/23)
```{r}

## read in FAO shapefile
fao_regions <- readOGR(dsn = file.path(dir_M, "git-annex/Global/NCEAS-Regions_v2014/orig/FAO_AREAS"), layer="FAO_AREAS")  
fao_regions <- fao_regions[fao_regions$F_LEVEL == "MAJOR", ]
plot(fao_regions)

## plot FAO over watson raster
plot(watson_rast)
plot(fao_regions, add=TRUE)

## grab cell values for each fao region
fao_to_saup_raster <- raster::extract(watson_rast, fao_regions, weights = TRUE, normalizeWeights = FALSE, progress = 'text') 

## assign corresponding fao region codes
names(fao_to_saup_raster) <- paste(fao_regions$OCEAN, fao_regions$F_CODE, sep="_") 

## combine elements into single data frame
region_df <- plyr::ldply(fao_to_saup_raster, rbind)

region_df <- region_df %>%
  separate(.id, c('ocean', 'fao_id'), sep = '_') %>%
  rename(wat_cell_id = value)

## filter out regions partially covering a cell 
region_df <- region_df %>%
  group_by(wat_cell_id) %>%
  mutate(is.max = ifelse(weight == max(weight), "max", NA)) %>%
  ungroup() %>%
  filter(!is.na(is.max)) %>%
  dplyr::select(wat_cell_id, ocean, fao_id) %>%
  data.frame()

# these are duplicates, probably due to 50% coverage between two regions, just select one fao id randomly: (not sure where `fao_rgns` is so changing it to `region_df`
# dups <- fao_rgns$wat_cell_id[duplicated(fao_rgns$wat_cell_id)]
# random_delete <- fao_rgns[fao_rgns$wat_cell_id %in% dups, ] %>%
#   group_by(wat_cell_id) %>%
#   sample_n(1)
dups <- region_df$wat_cell_id[duplicated(region_df$wat_cell_id)]

length(dups)
test <- region_df %>% filter(wat_cell_id == dups[7]) # change index
head(test) # check out fao_ids that share cell, drop one of them

## here is what was randomly selected for deletion:
region_df <- filter(region_df, !(wat_cell_id == 211186 & fao_id == 41))
region_df <- filter(region_df, !(wat_cell_id == 211906 & fao_id == 41))
region_df <- filter(region_df, !(wat_cell_id == 212626 & fao_id == 41))
region_df <- filter(region_df, !(wat_cell_id == 213346 & fao_id == 41))
region_df <- filter(region_df, !(wat_cell_id == 214066 & fao_id == 87))
region_df <- filter(region_df, !(wat_cell_id == 214786 & fao_id == 87))
region_df <- filter(region_df, !(wat_cell_id == 215506 & fao_id == 41))


## save all the cell associations
write.csv(region_df, file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_fao_rgns.csv"), row.names=FALSE)

```

*** 

## Final Wrangling of Cells

Read in the dataset matching each cell to an FAO region (need both OHI and FAO region for analysis)

If the cell covers greater than 1 region (or duplicated), leave it be. If it doesn't cover greater than 1 region, then change cell areas to 1 to capture entire cell's catch (these are less than 1 area due to edge effects)

Note: Currently `cells` (I think cell-ohi) range from 8 to 259,200. `region_df` (I think cell-fao) ranges from 1 to 252,083. After joining, `cells_df` ranges from 8 to 259,200.
```{r}

region_df <- read.csv(file.path(dir_M, "git-annex/globalprep/fis/v2018/raw/watson_rasters_to_fao_rgns.csv")) %>%
  rename(CellID = wat_cell_id)

cells_df <- cells %>%
  mutate(area = ifelse(CellID %in% dup, area, 1)) %>% 
  left_join(region_df) 

summary(cells_df) # Some NAs in fao_id

```

From `summary(cells_df)` we see that there are many NAs in the `fao_id` field. The corresponding `ocean` field is also an NA.

One issue of concern: Some regions aren't assigned an FAO region value (in places where land > 50% of cell cover)...and we need both for the analysis
```{r}

## see what percentage have no FAO region assigned
sum(is.na(cells_df$fao_id))/max(cells$CellID) # 83803/259200 or 32% is NA

## check to see how many cell IDs remain after we take out the land cells:
cells_df_water <- cells_df %>%
  filter(CellID %in% cells_water$CellID)

summary(cells_df_water)

## check percentage of cells that are missing
## N = 558, and only 0.2% of all cells...not too bad???...does not seem worth fretting over??
## cells_df_water has same max cell id as region_df
sum(is.na(cells_df_water$fao_id))/max(cells_df_water$CellID) # 558/252083

```

***

## Save File
```{r}
write.csv(cells_df_water, file = "cells.csv")
```

